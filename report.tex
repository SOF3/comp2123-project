\documentclass{article}
\title{COMP2123 self-learning report \\
Unit testing}

\input{commands}

\begin{document}
\rem{TODO: Change \bs{}iftrue in commands.tex \bs{}def\bs{}rem to \bs{}iffalse in final copy}

\maketitle
\begin{abstract}
This report discusses the motivation, available techniques and difficulties of unit testing.
\end{abstract}
\newpage

{\hypersetup{hidelinks}
	\tableofcontents
}
\newpage

\section{What is unit testing?}
Unit testing is the practice of testing every small unit of a large project instead of only testing the output.

\section{Motivation}
\subsection{Discover bugs early}
As the scale of a software project grows, debugging becomes more complicated.
It may take a long time to discover edge case bugs in an old component, which is very difficult to debug after a long time.
Unit testing allows identification of bugs as soon as possible with little impact.

\subsection{As a method of specification}
Unit testing can also be used as a means of project requirement specification.

\section{Unit testing methods}
\subsection{Testing for expected result}
The intuitive way is to write a test that tests the output of each function.

\begin{lstlisting}[style=Cpp]
class SimpleSpec {
public:
	void testFooBar() {
		ASSERT_EQUAL(fooBar(), "qux")
	}
}
\end{lstlisting}

The \texttt{ASSERT\_EQUAL} macro function would compare the result of \texttt{fooBar()} with \texttt{"qux"} and trigger an error if they are not equal.
This macro function can be implemented very easily:

\begin{lstlisting}[style=Cpp]
#define ASSERT_EQUAL(actual, expect) if(actual != expect) \
	throw sprintf("Test for %s failed: expected, %s, got %s", \
	#actual, expect, actual);
\end{lstlisting}

Some other common assertions include:
\begin{itemize}
	\item Null checks
	\item Arithmetic comparisons > >= < <=
	\item That an exception must be gracefully thrown
\end{itemize}

By running a series of similar tests every time before moving to another project subcomponent,
bugs can be identified before it spreads to other components.
This is particularly helpful when certain bugfixes might result in prototype changes,
resulting in incompatibility with other components during bugfixes.

\subsection{Generating test parameters}
If a function accepts a parameter, it is not possible to execute a test on every possible parameter value.
Instead, the parameters can be generated randomly in every test.
By supplying a test sample large enough, most bugs can be discovered quickly.

\rem{Generate parameters randomly, possibly by reverse calculation}

\subsubsection{Testing for edge cases}
\rem{E.g. test for empty strings, Float.INFINITY, 0, etc.}

\subsection{Test case selection}
As the number of variables to a feature increases, the number of test cases might increase exponentially.

\section{Unit testing techniques}
\subsection{Test coverage}
Test coverage is a criterion to assess the representativeness of the unit tests of a project by counting the number of lines executed in the test.

\rem{Talk about the integration of debuggers and how to interpret coverage}

\subsection{Test-driven development (TDD)}
As a consequence of unit testing, development flow becomes more fluent if each development subtask is based on certain test cases.

\subsection{Behaviour-driven development (BDD)}

\rem{Refer to cucumber}

\subsection{Dependency mocking}
\rem{https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/ provides some insight on why mocking is bad}

\section{Coupling between units}

\end{document}
