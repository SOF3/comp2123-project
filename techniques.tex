\section{Unit testing techniques}
\subsection{Test coverage}
Test coverage is a criterion to assess the representativeness of the unit tests of a project by counting the number of lines executed in the test.

\rem{Talk about the integration of debuggers and how to interpret coverage (codecov.io)}

\subsection{Test-driven development (TDD)}
As a consequence of unit testing, development flow becomes more fluent if each development subtask is based on certain test cases. By using TDD, it ensures that every part of the program can be tested properly, as nearly all code is writen based on pre-written test cases. It also prevents writing duplicated code in large collaborative projects, and TDD can avoid waste of time for implmenting already done features/requirements. 

The workflow of TDD is as follows:

\begin{enumerate}
	\item Create a new unit test for the software for a requirement that has not yet been implemented. 
	\item Run the unit test. If the unit test passes, this means the new test overlaps with previously written tests, and that a new test should be written to cover the new requirement
	\item Write code to pass (only) the newly added test, while ensuring previous tests also pass
	\item Run the tests
	\item Repeat the above process for every requirement
\end{enumerate}

Suppose we want to write a calulator with a fucntion \texttt{int add(string numbers)} that has the following requirements:

\begin{enumerate}
	\item The method can take in any amount of space-separated integers as an input, and return their sum.
	\item If the string is empty, the method should return \texttt{0}.
	\item If non-space-and-digit characters are passed within the string, the method throw an "Invalid character" exception. 
\end{enumerate}

We begin the development process by writing the test for the first requirement as follows:

\rem C++ test

As the \texttt{sum} method is currently empty, the test fails as expected. So we can proceed to write the code which solves this test:

\cpp{calculator1.cpp}

To verify our implementation, we run the test we have written in test 1:

\rem Run test, success

And we can continue with the next test. 

\textbf{Exercise 1: Write the test and the code for the second test.}

\subsection{Behaviour-driven development (BDD)}

While TDD provides a reliable method to test individual function executions, it cannot precisely and concisely define functions that depend on global/object states.

The main difference between TDD and BDD is that while TDD ensures that every sub-component of the software is correct, BDD provides a more "high-level" view of what the entire software should provide to the user. It is often regarded as a "bridge" between product designers and developers, as through BDD, product designers can effectively communicate their needs to devlopers who specialize in implementing those requirements. 

BDD defines the behaviour of a function using some specific terms or keywords. Each of these is written in the format of a "user story", and follow special "syntax" via the usage of certain keywords. The usage of these keywords are important, as a user story can be automatically phrased into "testable" code with a framework (such as Cucumber, on next section), given that it is formatted correctly with those "grammar". Here we present some of the keywords, along with the syntax general to most BDD frameworks:

The following is an example BDD of Cucumber:

\begin{lstlisting}
Scenario Outline: eating
  Given there are <start> cucumbers
  When I eat <eat> cucumbers
  Then I should have <left> cucumbers

  Examples:
    | start | eat | left |
    |    12 |   5 |    7 |
    |    20 |   5 |   15 |
\end{lstlisting}

\paragraph{Scenario Outline}

Describes a situation where that the software should be able to handle properly, defines the behavior of the program for a certain situation. 

\paragraph{Given}

The initial state of the program when this scenario takes place

\paragraph{When}

Similar to natural English, "When" implies that the following statement should be done "when" this statement is completed

\paragraph{Then}

Describes the expected output of the program after the preceeding "when" statement is fulfilled. 

The code above are extracted from the official Cucumber Documentation, which you can access at \url{https://docs.cucumber.io/gherkin/reference/}

This framework also subclassifies a task into multiple components to identify the exact source of error.

\rem{Refer to cucumber's framework}

\rem{To read: https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/}

\subsection{Dependency mocking}
\rem{https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/ provides some insight on why mocking is bad}
\rem{Consider moving this to the part about coupling}


