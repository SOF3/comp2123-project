\section{Unit testing techniques}
\subsection{Test coverage}
Test coverage is a criterion to assess the representativeness of the unit tests of a project by counting the number of lines executed in the test.

\rem{Talk about the integration of debuggers and how to interpret coverage (codecov.io)}

\subsection{Test-driven development (TDD)}
As a consequence of unit testing, development flow becomes more fluent if each development subtask is based on certain test cases. By using TDD, it ensures that every part of the program can be tested properly, as nearly all code is writen based on pre-written test cases. It also prevents writing duplicated code in large collaborative projects, and TDD can avoid waste of time for implmenting already done features/requirements. 

The workflow of TDD is as follows:

\begin{enumerate}
	\item Create a new unit test for the software for a requirement that has not yet been implemented. 
	\item Run the unit test. If the unit test passes, this means the new test overlaps with previously written tests, and that a new test should be written to cover the new requirement
	\item Write code to pass (only) the newly added test, while ensuring previous tests also pass
	\item Run the tests
	\item Repeat the above process for every requirement
\end{enumerate}

Suppose we want to write a calulator with a fucntion \texttt{int add(string numbers)} that has the following requirements:

\begin{enumerate}
	\item The method can take in any amount of space-separated integers as an input, and return their sum.
	\item If the string is empty, the method should return \texttt{0}.
	\item If non-space-and-digit characters are passed within the string, the method throw an "Invalid character" exception. 
\end{enumerate}

We begin the development process by writing the test for the first requirement as follows:

\rem C++ test

As the \texttt{sum} method is currently empty, the test fails as expected. So we can proceed to write the code which solves this test:

\cpp{calculator1.cpp}

To verify our implementation, we run the test we have written in test 1:

\rem{Run test, success}

And we can continue with implementing the next requirement. 

\textbf{Exercise: Write the test and implementation for the second test.}

\subsection{Behaviour-driven development (BDD)}

While TDD provides a reliable method to test individual function executions, it cannot precisely and concisely define functions that depend on global/object states.

The main difference between TDD and BDD is that while TDD ensures that every sub-component of the software is correct, BDD provides a more "high-level" view of what the entire software should provide to the user. It is often regarded as a "bridge" between product designers and developers, as through BDD, product designers can effectively communicate their needs to devlopers who specialize in implementing those requirements. 

BDD defines the behaviour of a function using some specific terms or keywords. Each of these is written in the format of a "user story", and follow special "syntax" via the usage of certain keywords. The usage of these keywords are important, as a user story can be automatically phrased into "testable" code with a framework (such as Cucumber, on next section), given that it is formatted correctly with those "grammar". Here we present some of the keywords, along with the syntax general to most BDD frameworks:

The following is an example BDD of Cucumber:

\begin{lstlisting}
Feature: Is it Friday yet?
  Everybody wants to know when it's Friday

  Scenario: Sunday isn't Friday
    Given today is Sunday
    When I ask whether it's Friday yet
    Then I should be told "Nope"
\end{lstlisting}

\paragraph{Feature}

Describes a feature that the software should provide on the high-level, with some description

\paragraph{Scenario}

Describes a situation (similar to example) where that the software should be able to handle properly, defines the behavior of the program for a certain (more specific) situation. 

\paragraph{Given}

The initial state of the program when this scenario takes place

\paragraph{When}

Similar to natural English, "When" implies that the following statement should be done "when" this statement is completed

\paragraph{Then}

Describes the expected output of the program after the preceeding "when" statement is fulfilled. 

Why is such grammar important? As a software developer, we may often find it difficult to translate requirements given by product designers/users into code. By having the product designers write their requirements in such a fashion which is both "human readable" and "machine prasable", it is possible to translate those requirements in to unit tests \textbf{automatically}. For example, in Cucumber, the following can be generated automatically from the above BDD, which can be further manipulated to contain actual machine-runnable tests (in fact a BDD is just a combination of multiple unit tests, but written in a high-level manner):

\java{cucumber_unit_test.java}

If you are interested to learn more, head over to \url{http://docs.cucumber.io/guides/10-minute-tutorial/} to get started with the Cucumber framework!

\subsection{Summary: TDD vs BDD}

As you can see, the description of the program behavior in BDD is more "high level" compared to TDD. The person writing BDDs ususally writes them from a user's perspective, where they might not have full knowledge on the internals of the software. On the other hand, TDDs focus more on the internal working on the software, and whether each part functions correctly. 

Often in BDD, when a test fails, it is difficult to locate the root cause of the error, as the BDD usually involves the whole piece of software instead of a single modular component and it is difficult to locate a bug in the whole program as opposed to a single function. (in Cucumber, the framework subclassifies a task into multiple components to help to identify the exact source of error, but the subclassification is not as small as those in TDD). Furthermore, as BDD involves running the whole software to conduct behavior tests, it takes much longer to conduct a single test (a BDD test can take up to a minute, while a TDD test may only take a few seconds). 

The existence of BDDs is to keep developers on track on building products that directly address the user's requirements, instead of building functions that satisfy a low-level requirement. This means, that in BDD the software development is driven by how the user will use the software, and the program is built accordingly, while for TDD, it involves the concept where the correctness of a software implies that all sub-components are correctly writen, meaning that code is built according to the feature of a certain component, but not the whole picture. 

This means if a BDD test fails, it implies that there is a use case that the software will have a bug in regular use, and should not be released. On the other hand, if BDD passes and a TDD fails, this implies that although some components may contain bugs, in regular usage, they will not affect the running of the whole software, and the software can continue with its release, leaving the bug fix for later. 

\subsection{Dependency mocking}

Often (if not always), sub-components in a software will have other components as dependencies. Take our calculator class as an example. Suppose we want to write a function \texttt{int eval(int a, int b, char operation)}

\cpp{calculator2.cpp}

The implementation is done, and we have unit tests for this code. Now lets say that there is a new requirement, that if the result of the calculation exceeds the value of \texttt{int} (2^{31}-1), it should throw an OverflowException. A trivial idea for implementation would be to implement the internal calcualtion of the operation via another data type that supports larger range (e.g. \texttt{long long}, \texttt{BigInteger}), and compare this value with 2^{31}-1. In other words, we can write the following instead:

\cpp{calculator3.cpp}

The \texttt{Calculator} now depends on \texttt{BigInteger}. Assume that we have not implemented or tested our implementation of \texttt{BigInteger} yet, how are we going to test the component of \texttt{Calculator}? One of the ways is to substitute \texttt{BigInteger} with another "fake" BigInteger, which for the purpose of explanation, we assume the implementation is correct.

\cpp{Fake_BigInteger.h}

Now our \texttt{Calculator} class can compile successfully, and we can test the implementation of \texttt{Calculator} without caring about the correctness of \texttt{BigInteger}. 

This is exactly what "Dependency mocking" is. If inside the target we want to perform unit tests on, has a function call which either is untested, or we do not want to call (due to lack of resources, take long time to run), we can essentially substitute that function with another one which produces the "expected result" of the original function, assuming that the implementation of the original function was correct. 

However, although mocking effectively isolates this component from other components, making unit testing relevant to the implementation of only the target, mocking has several disadvantages for software development. In actual software development, the implementation of the "outside" function is often replaced with a single return statement, which has been pre-written and hardcoded to return the expected output for a pre-determined unit test. 

If you want to know more about mocking and its disadvantages, check out \url{https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/} for some additional insight on why mocking is bad. 