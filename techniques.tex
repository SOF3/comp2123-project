\section{Unit testing techniques}
\subsection{Test coverage}
Test coverage is a criterion to assess the representativeness of the unit tests of a project by counting the number of lines executed in the test.

\rem{Talk about the integration of debuggers and how to interpret coverage (codecov.io)}

\subsection{Test-driven development (TDD)}
As a consequence of unit testing, development flow becomes more fluent if each development subtask is based on certain test cases. By using TDD, it ensures that every part of the program can be tested properly, as nearly all code is writen based on pre-written test cases. It also prevents writing duplicated code in large collaborative projects, and TDD can avoid waste of time for implmenting already done features/requirements. 

The workflow of TDD is as follows:

\begin{enumerate}
	\item Create a new unit test for the software for a requirement that has not yet been implemented. 
	\item Run the unit test. If the unit test passes, this means the new test overlaps with previously written tests, and that a new test should be written to cover the new requirement
	\item Write code to pass (only) the newly added test, while ensuring previous tests also pass
	\item Run the tests
	\item Repeat the above process for every requirement
\end{enumerate}

Suppose we want to write a calulator with a fucntion \texttt{int add(string numbers)} that has the following requirements:

\begin{enumerate}
	\item The method can take in any amount of space-separated integers as an input, and return their sum.
	\item If the string is empty, the method should return \texttt{0}.
	\item If non-space-and-digit characters are passed within the string, the method throw an "Invalid character" exception. 
\end{enumerate}

We begin the development process by writing the test for the first requirement as follows:

\rem C++ test

As the \texttt{sum} method is currently empty, the test fails as expected. So we can proceed to write the code which solves this test:

\cpp{calculator1.cpp}

To verify our implementation, we run the test we have written in test 1:

\rem Run test, success

And we can continue with the next test. 

\textbf{Exercise 1: Write the test and the code for the second test.}

\subsection{Behaviour-driven development (BDD)}

While TDD provides a reliable method to test individual function executions, it cannot precisely and concisely define functions that depend on global/object states.

The main difference between TDD and BDD is that while TDD ensures that every sub-component of the software is correct, BDD provides a more "high-level" view of what the entire software should provide to the user. It is often regarded as a "bridge" between product designers and developers, as through BDD, product designers can effectively communicate their needs to devlopers who specialize in implementing those requirements. 

BDD defines the behaviour of a function using some specific terms or keywords. Each of these is written in the format of a "user story", and follow special "syntax" via the usage of certain keywords. The usage of these keywords are important, as a user story can be automatically phrased into "testable" code with a framework (such as Cucumber, on next section), given that it is formatted correctly with those "grammar". Here we present some of the keywords, along with the syntax general to most BDD frameworks:

The following is an example BDD of Cucumber:

\begin{lstlisting}
\textbf{Feature}: Is it Friday yet?
  Everybody wants to know when it's Friday

  \textbf{Scenario}: Sunday isn't Friday        # hellocucumber/is_it_friday_yet.feature:4
    \textbf{Given} today is Sunday              # null
    \textbf{When} I ask whether it's Friday yet # null
    \textbf{Then} I should be told "Nope"       # null
\end{lstlisting}

\paragraph{Feature}

Describes a feature that the software should provide on the high-level, with some description

\paragraph{Scenario}

Describes a situation (similar to example) where that the software should be able to handle properly, defines the behavior of the program for a certain (more specific) situation. 

\paragraph{Given}

The initial state of the program when this scenario takes place

\paragraph{When}

Similar to natural English, "When" implies that the following statement should be done "when" this statement is completed

\paragraph{Then}

Describes the expected output of the program after the preceeding "when" statement is fulfilled. 

Why is such grammar important? As a software developer, we may often find it difficult to translate requirements given by product designers/users into code. By having the product designers write their requirements in such a fashion which is both "human readable" and "machine prasable", it is possible to translate those requirements in to unit tests \textbf{automatically}. For example, in Cucumber, the following can be generated automatically from the above BDD, which can be further manipulated to contain actual machine-runnable tests:

\java{cucumber_unit_test.java}

If you are interested to learn more, head over to \url{http://docs.cucumber.io/guides/10-minute-tutorial/} to get started with the Cucumber framework!

\subsection{Summary: TDD vs BDD}

As you can see, the description of the program behavior in BDD is more "high level" compared to TDD. The person writing BDDs ususally writes them from a user's perspective, where they might not have full knowledge on the internals of the software. On the other hand, TDDs focus more on the internal working on the software, and whether each part functions correctly. 

This framework also subclassifies a task into multiple components to identify the exact source of error.

\rem{Refer to cucumber's framework}

\rem{To read: https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/}

\subsection{Dependency mocking}
\rem{https://enterprisecraftsmanship.com/2016/06/09/styles-of-unit-testing/ provides some insight on why mocking is bad}
\rem{Consider moving this to the part about coupling}
