        -:    0:Source:libs/rapidcheck/include/rapidcheck/detail/Variant.hpp
        -:    0:Programs:6
        -:    1:#pragma once
        -:    2:
        -:    3:namespace rc {
        -:    4:namespace detail {
        -:    5:
        -:    6:template <typename... Types>
        -:    7:struct IndexHelper;
        -:    8:
        -:    9:template <>
        -:   10:struct IndexHelper<> {
        -:   11:  template <typename T>
        -:   12:  static constexpr std::size_t indexOf() {
        -:   13:    return 0;
        -:   14:  }
        -:   15:};
        -:   16:
        -:   17:template <typename First, typename... Types>
        -:   18:struct IndexHelper<First, Types...> {
        -:   19:  template <typename T>
        5:   20:  static constexpr std::size_t indexOf() {
        -:   21:    return std::is_same<First, T>::value
        -:   22:        ? 0
        5:   23:        : IndexHelper<Types...>::template indexOf<T>() + 1;
        -:   24:  }
        -:   25:};
        -:   26:
        -:   27:template <typename Type, typename... Types>
        -:   28:template <typename T, typename>
        -:   29:Variant<Type, Types...>::Variant(T &&value) noexcept(
        -:   30:    std::is_nothrow_constructible<Decay<T>, T &&>::value)
        -:   31:    : m_typeIndex(indexOfType<Decay<T>>()) {
        -:   32:  static_assert(isValidType<Decay<T>>(),
        -:   33:                "T is not a valid type of this variant");
        -:   34:
        -:   35:  new (&m_storage) Decay<T>(std::forward<T>(value));
        -:   36:}
        -:   37:
        -:   38:template <typename Type, typename... Types>
        -:   39:template <typename T, typename>
        -:   40:Variant<Type, Types...> &Variant<Type, Types...>::
        -:   41:operator=(const T &value) noexcept {
        -:   42:  static_assert(isValidType<T>(), "T is not a valid type of this variant");
        -:   43:
        -:   44:  const auto newIndex = indexOfType<T>();
        -:   45:  if (newIndex == m_typeIndex) {
        -:   46:    *reinterpret_cast<T *>(&m_storage) = value;
        -:   47:  } else {
        -:   48:    destroy(m_typeIndex, &m_storage);
        -:   49:    m_typeIndex = newIndex;
        -:   50:    new (&m_storage) T(value);
        -:   51:  }
        -:   52:  return *this;
        -:   53:}
        -:   54:
        -:   55:template <typename Type, typename... Types>
        -:   56:template <typename T, typename>
        -:   57:Variant<Type, Types...> &Variant<Type, Types...>::
        -:   58:operator=(T &&value) noexcept {
        -:   59:  static_assert(isValidType<T>(), "T is not a valid type of this variant");
        -:   60:
        -:   61:  const auto newIndex = indexOfType<T>();
        -:   62:  if (newIndex == m_typeIndex) {
        -:   63:    *reinterpret_cast<T *>(&m_storage) = std::move(value);
        -:   64:  } else {
        -:   65:    destroy(m_typeIndex, &m_storage);
        -:   66:    m_typeIndex = newIndex;
        -:   67:    new (&m_storage) T(std::move(value));
        -:   68:  }
        -:   69:  return *this;
        -:   70:}
        -:   71:
        -:   72:template <typename Type, typename... Types>
        -:   73:template <typename T>
        -:   74:T &Variant<Type, Types...>::get() & {
        -:   75:  assert(indexOfType<T>() == m_typeIndex);
        -:   76:  return *reinterpret_cast<T *>(&m_storage);
        -:   77:}
        -:   78:
        -:   79:template <typename Type, typename... Types>
        -:   80:template <typename T>
        -:   81:const T &Variant<Type, Types...>::get() const & {
        -:   82:  assert(indexOfType<T>() == m_typeIndex);
        -:   83:  return *reinterpret_cast<const T *>(&m_storage);
        -:   84:}
        -:   85:
        -:   86:template <typename Type, typename... Types>
        -:   87:template <typename T>
        -:   88:T &&Variant<Type, Types...>::get() && {
        -:   89:  return std::move(get<T>());
        -:   90:}
        -:   91:
        -:   92:// TODO this would be more fun with varargs and lambdas
        -:   93:template <typename Type, typename... Types>
        -:   94:template <typename T>
        -:   95:bool Variant<Type, Types...>::match(T &value) const {
        -:   96:  if (!is<T>()) {
        -:   97:    return false;
        -:   98:  }
        -:   99:
        -:  100:  value = *reinterpret_cast<const T *>(&m_storage);
        -:  101:  return true;
        -:  102:}
        -:  103:
        -:  104:template <typename Type, typename... Types>
        -:  105:template <typename T>
        4:  106:bool Variant<Type, Types...>::is() const {
        -:  107:  static_assert(isValidType<Decay<T>>(),
        -:  108:                "T is not a valid type of this variant");
        4:  109:  return m_typeIndex == indexOfType<T>();
        -:  110:}
        -:  111:
        -:  112:template <typename T>
        -:  113:bool variantEqualsImpl(const void *lhs, const void *rhs) {
        -:  114:  return *static_cast<const T *>(lhs) == *static_cast<const T *>(rhs);
        -:  115:}
        -:  116:
        -:  117:template <typename Type, typename... Types>
        -:  118:bool Variant<Type, Types...>::operator==(const Variant &rhs) const {
        -:  119:  if (m_typeIndex != rhs.m_typeIndex) {
        -:  120:    return false;
        -:  121:  }
        -:  122:
        -:  123:  static bool (*const equalsFuncs[])(const void *, const void *) = {
        -:  124:      &variantEqualsImpl<Type>, &variantEqualsImpl<Types>...};
        -:  125:
        -:  126:  return equalsFuncs[m_typeIndex](&m_storage, &rhs.m_storage);
        -:  127:}
        -:  128:
        -:  129:template <typename T>
        -:  130:void variantPrintToImpl(std::ostream &os, const void *storage) {
        -:  131:  os << *static_cast<const T *>(storage);
        -:  132:}
        -:  133:
        -:  134:template <typename Type, typename... Types>
        -:  135:void Variant<Type, Types...>::printTo(std::ostream &os) const {
        -:  136:  static void (*printToFuncs[])(std::ostream &, const void *) = {
        -:  137:      &variantPrintToImpl<Type>, &variantPrintToImpl<Types>...};
        -:  138:
        -:  139:  printToFuncs[m_typeIndex](os, &m_storage);
        -:  140:}
        -:  141:
        -:  142:template <typename Type, typename... Types>
        -:  143:Variant<Type, Types...>::Variant(const Variant &other) noexcept(
        -:  144:    AllIs<std::is_nothrow_copy_constructible, Type, Types...>::value)
        -:  145:    : m_typeIndex(other.m_typeIndex) {
        -:  146:  copy(m_typeIndex, &m_storage, &other.m_storage);
        -:  147:}
        -:  148:
        -:  149:template <typename Type, typename... Types>
        -:  150:Variant<Type, Types...>::Variant(Variant &&other) noexcept(
        -:  151:    AllIs<std::is_nothrow_move_constructible, Type, Types...>::value)
        -:  152:    : m_typeIndex(other.m_typeIndex) {
        -:  153:  move(m_typeIndex, &m_storage, &other.m_storage);
        -:  154:}
        -:  155:
        -:  156:template <typename Type, typename... Types>
        -:  157:Variant<Type, Types...> &Variant<Type, Types...>::
        -:  158:operator=(const Variant &rhs) noexcept(
        -:  159:    AllIs<std::is_nothrow_copy_constructible, Type, Types...>::value
        -:  160:        &&AllIs<std::is_nothrow_copy_assignable, Type, Types...>::value) {
        -:  161:  static_assert(
        -:  162:      AllIs<std::is_nothrow_move_constructible, Type, Types...>::value,
        -:  163:      "AllIs types must be nothrow move-constructible to use copy assignment");
        -:  164:
        -:  165:  if (m_typeIndex == rhs.m_typeIndex) {
        -:  166:    copyAssign(m_typeIndex, &m_storage, &rhs.m_storage);
        -:  167:  } else {
        -:  168:    Storage tmp;
        -:  169:    copy(rhs.m_typeIndex, &tmp, &rhs.m_storage);
        -:  170:    destroy(m_typeIndex, &m_storage);
        -:  171:    move(rhs.m_typeIndex, &m_storage, &tmp);
        -:  172:    m_typeIndex = rhs.m_typeIndex;
        -:  173:  }
        -:  174:
        -:  175:  return *this;
        -:  176:}
        -:  177:
        -:  178:template <typename Type, typename... Types>
        -:  179:Variant<Type, Types...> &Variant<Type, Types...>::
        -:  180:operator=(Variant &&rhs) noexcept(
        -:  181:    AllIs<std::is_nothrow_move_assignable, Type, Types...>::value) {
        -:  182:  static_assert(
        -:  183:      AllIs<std::is_nothrow_move_constructible, Type, Types...>::value,
        -:  184:      "AllIs types must be nothrow move-constructible to use copy assignment");
        -:  185:
        -:  186:  if (m_typeIndex == rhs.m_typeIndex) {
        -:  187:    moveAssign(m_typeIndex, &m_storage, &rhs.m_storage);
        -:  188:  } else {
        -:  189:    destroy(m_typeIndex, &m_storage);
        -:  190:    m_typeIndex = rhs.m_typeIndex;
        -:  191:    move(m_typeIndex, &m_storage, &rhs.m_storage);
        -:  192:  }
        -:  193:
        -:  194:  return *this;
        -:  195:}
        -:  196:
        -:  197:template <typename Type, typename... Types>
        2:  198:Variant<Type, Types...>::~Variant() noexcept {
        2:  199:  destroy(m_typeIndex, &m_storage);
        2:  200:}
        -:  201:
        -:  202:template <typename T>
        -:  203:void variantCopyAssign(void *to, const void *from) {
        -:  204:  *static_cast<T *>(to) = *static_cast<const T *>(from);
        -:  205:}
        -:  206:
        -:  207:template <typename Type, typename... Types>
        -:  208:void Variant<Type, Types...>::copyAssign(std::size_t index,
        -:  209:                                         void *to,
        -:  210:                                         const void *from) {
        -:  211:  static void (*const copyAssignFuncs[])(void *, const void *) = {
        -:  212:      &variantCopyAssign<Type>, &variantCopyAssign<Types>...};
        -:  213:
        -:  214:  copyAssignFuncs[index](to, from);
        -:  215:}
        -:  216:
        -:  217:template <typename T>
        -:  218:void variantMoveAssign(void *to, void *from) {
        -:  219:  *static_cast<T *>(to) = std::move(*static_cast<T *>(from));
        -:  220:}
        -:  221:
        -:  222:template <typename Type, typename... Types>
        -:  223:void Variant<Type, Types...>::moveAssign(std::size_t index,
        -:  224:                                         void *to,
        -:  225:                                         void *from) {
        -:  226:  static void (*const moveAssignFuncs[])(void *, void *) = {
        -:  227:      &variantMoveAssign<Type>, &variantMoveAssign<Types>...};
        -:  228:
        -:  229:  moveAssignFuncs[index](to, from);
        -:  230:}
        -:  231:
        -:  232:template <typename T>
        -:  233:void variantCopy(void *to, const void *from) {
        -:  234:  new (to) T(*static_cast<const T *>(from));
        -:  235:}
        -:  236:
        -:  237:template <typename Type, typename... Types>
        -:  238:void Variant<Type, Types...>::copy(std::size_t index,
        -:  239:                                   void *to,
        -:  240:                                   const void *from) {
        -:  241:  static void (*const copyFuncs[])(void *, const void *) = {
        -:  242:      &variantCopy<Type>, &variantCopy<Types>...};
        -:  243:
        -:  244:  copyFuncs[index](to, from);
        -:  245:}
        -:  246:
        -:  247:template <typename T>
        -:  248:void variantMove(void *to, void *from) {
        -:  249:  new (to) T(std::move(*static_cast<T *>(from)));
        -:  250:}
        -:  251:
        -:  252:template <typename Type, typename... Types>
        -:  253:void Variant<Type, Types...>::move(std::size_t index, void *to, void *from) {
        -:  254:  static void (*const moveFuncs[])(void *, void *) = {&variantMove<Type>,
        -:  255:                                                      &variantMove<Types>...};
        -:  256:
        -:  257:  moveFuncs[index](to, from);
        -:  258:}
        -:  259:
        -:  260:template <typename T>
       2*:  261:void variantDestroy(void *storage) {
       2*:  262:  static_cast<T *>(storage)->~T();
       2*:  263:}
------------------
_ZN2rc6detail14variantDestroyINS0_5ErrorEEEvPv:
    #####:  261:void variantDestroy(void *storage) {
    #####:  262:  static_cast<T *>(storage)->~T();
    #####:  263:}
------------------
_ZN2rc6detail14variantDestroyINS0_12GaveUpResultEEEvPv:
    #####:  261:void variantDestroy(void *storage) {
    #####:  262:  static_cast<T *>(storage)->~T();
    #####:  263:}
------------------
_ZN2rc6detail14variantDestroyINS0_13FailureResultEEEvPv:
        1:  261:void variantDestroy(void *storage) {
        1:  262:  static_cast<T *>(storage)->~T();
        1:  263:}
------------------
_ZN2rc6detail14variantDestroyINS0_13SuccessResultEEEvPv:
        1:  261:void variantDestroy(void *storage) {
        1:  262:  static_cast<T *>(storage)->~T();
        1:  263:}
------------------
        -:  264:
        -:  265:template <typename Type, typename... Types>
        2:  266:void Variant<Type, Types...>::destroy(std::size_t index,
        -:  267:                                      void *storage) noexcept {
        -:  268:  static void (*const destroyFuncs[])(void *) = {&variantDestroy<Type>,
        -:  269:                                                 &variantDestroy<Types>...};
        -:  270:
        2:  271:  destroyFuncs[index](storage);
        2:  272:}
        -:  273:
        -:  274:template <typename Type, typename... Types>
        -:  275:template <typename T>
        5:  276:constexpr std::size_t Variant<Type, Types...>::indexOfType() {
        5:  277:  return IndexHelper<Type, Types...>::template indexOf<T>();
        -:  278:}
        -:  279:
        -:  280:template <typename Type, typename... Types>
        -:  281:template <typename T>
        -:  282:constexpr bool Variant<Type, Types...>::isValidType() {
        -:  283:  return indexOfType<T>() < (sizeof...(Types) + 1);
        -:  284:}
        -:  285:
        -:  286:template <typename Type, typename... Types>
        -:  287:bool operator!=(const Variant<Type, Types...> &lhs,
        -:  288:                const Variant<Type, Types...> &rhs) {
        -:  289:  return !(lhs == rhs);
        -:  290:}
        -:  291:
        -:  292:template <typename Type, typename... Types, typename>
        -:  293:std::ostream &operator<<(std::ostream &os,
        -:  294:                         const Variant<Type, Types...> &value) {
        -:  295:  value.printTo(os);
        -:  296:  return os;
        -:  297:}
        -:  298:
        -:  299:} // namespace detail
        -:  300:} // namespace rc
